# -*- coding: utf-8 -*-
"""Wingorad_layer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lQe_Eu1nE_On3blJNZQoYQWzYBS3Z662

Creating the winograd layer
"""

import sys 
import torch

from traitlets.traitlets import All
class Winograd2x3():

    """Transformation matrices for winograd domain"""
    B = torch.tensor(
        [[1, 0, -1, 0], 
            [0, 1, 1, 0], 
            [0, -1, 1, 0], 
            [0, 1, 0, -1]],
        dtype=torch.float32
    )

    BT = B.transpose(1,0)

    G = torch.tensor(
        [[1,0,0],
        [1/2,1/2,1.2],
        [1/2,-1/2,1/2],
        [0,0,1]],
        dtype=torch.float32
        )
    
    GT = G.transpose(1,0)

    AT = torch.tensor(
        [[1,1,1,0],
         [0,1,-1,-1]],
        dtype=torch.float32
    )

    A = AT.transpose(1,0)

    # print(A)
    # print(G)
    # print(B)
    
    def __init__(self,filter_v = None):
        super(Winograd2x3,self).__init__()


    def forward(input,filter):
        """ Winograd convolution computation"""

        batch_size,in_channels,input_h,input_w = input.size()   
        # example for mnist (bs=32,in_c=1,h=28,w=28)

        num_filters , depth_filters, r,r_p = filter.size()


        """
        minimal filtering algorithm for computing m outputs 
        with an r-tap FIR filter -> F(2,3) (1D)/ F(2x2,3x3) (2D):

                    μ(F(m,r)) = m+r-1 multiplcationas
                    μ(F(mxn,rxs)) = (m+r-1)(n+s-1) multiplications
        1D: For F(2,3) -> 2x3 = 6 mult && m+r-1 = 2+3-1 =4 muls
        2D: For F(2x2,3x3)) = (m+r-1)(n+s-1) = (2+3-1)*(2+3-1) = 16 muls 
        

        """
        m = 2 
        alpha = m + r - 1 

        #overlaping 
        over = r-1 

        # transpose input by switching the first 2 dimensions
        input = torch.transpose(input,0,1)
        #assert input.size() == (in_channels,batch_size,input_h,input_w)

        tiles = (input_w-alpha) // over+1 
        p = batch_size *tiles*tiles 

        U = torch.zeros(num_filters,in_channels,alpha,alpha)
        V = torch.zeros(in_channels,p,alpha,alpha)

        for i in range(num_filters):
            for j in range(in_channels):

                U[i,j] = torch.matmul(
                    Winograd2x3.G,
                    torch.matmul(filter[i,j],Winograd2x3.GT)
                )
        for i in range(batch_size):
            for j in range(tiles):
                for k in range(tiles):
                    for l in range(in_channels):

                        b = i*(tiles*tiles)+j*tiles+k
                        v_h = j*over
                        v_w = k*over
                        V[l,b] = torch.matmul(

                            Winograd2x3.BT,
                            torch.matmul(input[l, i, v_h:v_h+alpha , v_w:v_w+alpha ],
                                         Winograd2x3.B)
                        )
        # V = torch.transpose(V,0,1)
        # return V
        
        M = torch.zeros(num_filters,p,alpha,alpha)

        for i in range(num_filters):
            for j in range(tiles):
                for k in range(in_channels):
                    M[i,j] += U[i,k]*V[k,j]
        
        Y = torch.zeros(num_filters,batch_size,input_h-r+1,input_h-r+1)

        for i in range(num_filters):
            for j in range(batch_size):
                for k in range(tiles):
                    for l in range(tiles):
                        b = i *(tiles)*(tiles)+k*tiles+l

                        y_h = k*m 
                        y_w = l*m

                        Y[i,j,y_h:y_h+m,y_w:y_w+m]=torch.matmul(Winograd2x3.AT,
                                                                torch.matmul(M[i,b],
                                                                             Winograd2x3.A))
        Y = torch.transpose(Y,0,1)
        return Y

Winograd2x3()

x = torch.randint(-3, 3, (16, 1, 28, 28), dtype=torch.float)
y = torch.randint(-3, 3, (8, 1, 3, 3), dtype=torch.float)

x.shape

y.shape

Y = Winograd2x3.forward(x,y)

Y

Y.shape

